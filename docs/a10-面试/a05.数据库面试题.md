### 关系型和非关系型数据库的区别（各自优点）

#### 关系型

- 使用表结构，支持SQL和复杂查询。
- 读写性能差，硬盘IO是瓶颈

#### 非关系型

- 非关系型基于键值对，不需要经过SQL层的解析，性能高。
- 无事务的处理

### 常用SQL语句（DDL,DML,DCL,TCL）

DDL：data definition language

```sql
create database
create table
alter table
drop table
```

DML: data manipulation language

```sql
select
update
delete
insert into
```

DCL: data control language

```sql
grant
revoke
deny
```

TCL: transaction control language

```sql
savepoint
rollback
commit
```

### 数据库中join的类型与区别

（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写

left join: 以左边的表为主表，左边的表没有的列不添加

inner join: 必须在两个表中都存在

outer join: 两个表中都包含

cross join: 笛卡尔连接，产生的结果集为两个表各自个数的乘积

### 数据库的索引类型

> https://www.cnblogs.com/study-everyday/p/7391477.html

索引是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。

缺点：占用空间；更新表时需要重建索引，导致降低速度。

#### 唯一索引： UNIQUE

例如：create unique index stusno on student（sno）；

表明此索引的每一个索引值只对应唯一的数据记录

#### 主键索引： primary key

通过其值唯一标识表中的每一行

#### 聚集索引（也叫聚簇索引）：cluster

在聚集索引中，表中行的物理顺序与列值（一般是主键的一列）的逻辑顺序相同。一个表只能包含一个聚集索引。 与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

非聚集索引表中行的物理顺序与键值的逻辑顺序不匹配。

### 聚集索引和非聚集索引的区别

> https://www.cnblogs.com/s-b-b/p/8334593.html

聚集索引的叶子节点就是对应的数据节点

非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

1. 使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
2. 非聚集索引尽量避免二次查询，可以大幅提升性能。
3. 不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。

### 唯一性索引和主键约束的区别

> [csdnblog](https://blog.csdn.net/wushuang5566110/article/details/8069997?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。

主键约束（PRIMARY KEY）

1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 
2) 是不可能（或很难）更新． 
3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．
4) 主健可作外健，唯一索引不可；

### 索引的优缺点

什么时候使用索引，什么时候不能使用索引（重点）

> https://blog.csdn.net/weixin_44535476/article/details/89256755

优点：检索速度；唯一性、表与表之间的连接性等。

缺点：时间、空间。

使用索引：查询操作多的时候。

不使用索引：规模小的表、很少使用的列、数据值少的列

修改性能远和检索性能是冲突的，经常会被批量更新的表可以具有索引，但批量操作的性能会由于索引而降低。

### 索引的底层实现

（B+树，为何不采用红黑树，B树）

B+树和B树相比红黑树更矮，查询遍历的节点更少

B+树相对B树，将数据全部存在在叶子节点，非叶节点（索引部分）更加灵活

### B树和B+树具体实现？



### 索引最左前缀问题？



### MySQL的性能优化？

### Mysql的索引优化？

### 数据库引擎介绍

> https://blog.csdn.net/qq_35642036/article/details/82820178

目前MySQL默认的存储引擎是InnoDB。

#### 选择

    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
       2. MyISAM更适合读密集的表，而InnoDB更适合写密集的表。
          在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。
       3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；

#### InnoDB为什么推荐使用自增ID作为主键？

  答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

#### 事务

InnoDB支持事务，MyISAM不支持。

对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度。

#### 外键

InnoDB支持外键，而MyISAM不支持。

对一个包含外键的InnoDB表转为MYISAM会失败

#### 聚集索引

InnoDB是聚集索引，数据和主键绑定；MyISAM是非聚集索引，索引保存数据文件的指针。

InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

![image-20210606160821960](../images/image-20210606160821960.png)

MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

![image-20210606160838428](../images/image-20210606160838428.png)

也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

#### 锁

InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

```sql
例如：
    t_user(uid, uname, age, sex) innodb;
    uid PK
    无其他索引
   	/* 命中索引，行锁。*/
    update t_user set age=10 where uid=1;  
    /* 未命中索引，表锁。*/
    update t_user set age=10 where uid != 1;           
 		/*无索引，表锁。*/
    update t_user set age=10 where name='chackca';    
```



### 数据库中事务的ACID

（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

> https://blog.csdn.net/zh521zh/article/details/69400053

原子性（Atomicity）：事务包含的所有操作要么全部成功，要么全部失败回滚

一致性（Consistency）：事务必须使数据库从一个一致性状态转变为另一个一致性状态，即执行前后都是满足一致性。如转账操作。

隔离性（Isolation）：并发的事务之间要相互隔离，不能相互干扰。 

持久性（Durability）：事务被提交后，数据库中数据的修改是永久的，即使故障也不会丢失对事务的操作。

### 数据库隔离级别

乐观锁和悲观锁？

（脏读、不可重复读、丢失修改、幻读，不同设置会出现的问题）

> https://www.cnblogs.com/jian-gao/p/10795407.html

4种隔离级别限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

**Read Uncommitted（读未提交）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

**Read Committed（读提交）**

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。

这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

**Repeatable Read（可重复读）**

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。

不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 

**Serializable（串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

### 幻读

> https://segmentfault.com/a/1190000016566788?utm_source=tag-newest

可以在 `RR` 下根据业务需求决定是否加锁，存在幻读风险我们加锁，不存在就不加锁

定义：幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。

### MVCC

> https://www.cnblogs.com/delav/p/9683908.html

MVCC（Multi-Version Concurrent Control），即多版本并发控制，通过保存数据在某个时间点的快照来实现，因此每个读操作都会看到一个一致性的视图，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。

### 数据库连接池的作用

- 资源复用：避免创建、释放连接引起的性能开销
- 加快响应速度
- 统一连接管理，避免资源泄露

### Mysql的表空间方式，各自特点



### 分布式事务

### 数据库的范式

### 数据的锁的种类，加锁的方式

### 视图的作用与使用方法（如何删除等）

### 分库分表，主从复制，读写分离。（我不会，也没碰到过）

### 项目中哪里用到了数据库，怎么用的

### Memcache和Redis了解

### 数据库索引的作用

### 数据库熟悉吗？（不熟悉啊，没关系，我问几个问题）知道索引吗？在什么场景下用索引，索引有什么好处，有什么缺点？

### 索引使用什么数据结构实现的

### 数据库事务介绍一下

### 数据库引擎了解吗

### 各种索引的理解（头条，小米，腾讯）

### 各种日志的理解（头条，小米）

### 怎么看哪一个查询是慢查询（头条）

### Redis的跳表（头条）

### Redis的持久化（小米，头条）

### Redis和Mem..的区别（小米，腾讯）

### 数据库三个重要范式

### mysql索引为什么用B+树

### mysql 事务

### 引擎

### mysql具体语句（跪了）

### 空间数据库和普通的关系型数据库查询sql有什么区别

### 如果在三维空间里面有一条直线，要你在数据库中查找哪些点落在这条线上，假设每行数据都是一个点，你会怎么做

### 关系型数据库中要快速查找某一个年龄的数量，假设有1亿条数据，你会怎么设计表，怎么设计索引

### 第三范式了解吗 

### redis可以用来做什么，掉电数据如何恢复

### 数据库死锁的场景，怎么解决，操作系统的死锁，怎么解决

### 如何实现一个CDN系统

### 数据库的ACID四种属性的底层实现原理

### 如何实现一个缓存系统

### 海量词汇统计出现频率

### 项目性能瓶颈在哪，数据库表怎么设计

### 假设项目的性能瓶颈出现在写数据库上，应该怎么解决峰值时写速度慢的问题

### 假设数据库需要保存一年的数据，每天一百万条数据，一张表最多存一千万条数据，应该怎么设计表

### 一亿条电话号码删除重复的部分，时间、空间复杂度尽可能低

### MongoDB如何实现事务，事务的隔离级别

### MongoDB副本集实现高可用的原理，raft过程，投票规则，日志复制的过程，rocksdb引擎的优点，LSM树讲解

### MongoDB高可用架构的原理

