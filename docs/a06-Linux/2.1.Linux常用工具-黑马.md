## vim编辑器

### 工作模式

1. 命令模式 -- 打开文件之后, 默认进入命令模式
2. 编辑模式 -- 需要输入一些命令, 切换到编辑模式
3. 末行模式 -- 在末行模式下可以输入一些命令

![image-20210124130322221](../images/image-20210124130322221.png)

### 命令模式

#### 移动光标

	h: ← 左移
	l: → 右移
	j: ↓ 下移
	k: ↑ 上移
	gg: 光标移动文件开头
	G: 光标移动到文件末尾
	0: 光标移动到行首
	$: 光标移动到行尾
	123G：跳转到第123行
#### 删除

并不是真的删除，实际上是剪切

	x: 删除光标后一个字符,相当于 Del
	X: 删除光标前一个字符,相当于 Backspace
	dw: 删除光标开始位置的字
	d0: 删除光标前本行所有内容
	D（d$）: 删除光标后本行所有内容
	dd: 删除光标所在行
	n dd 删除指定的行数
#### 撤销操作

	u: 一步一步撤销
	Ctr-r: 反撤销
#### 复制粘贴

	yy: 复制当前行
	n yy：复制 n 行
	p: 在光标所在位置向下新开辟一行,粘贴
	P: 从光标所在行, 开始粘贴
其他软件中使用 `CTRL + C` 复制的内容，可以在 **编辑模式** 下使用 **鼠标右键粘贴**

#### 可视模式

	v：按字移动
	配合 h、j、k、l 使用，使用y复制选中内容
#### 查找操作

	/hello -> 从光标所在位置向后查找 hello
		n: 下一个
		N：上一个
		
	？hello -> 从光标所在位置向前查找 hello
		n: 上一个
		N：下一个
		
	在要查询的单词上使用 # 进行查找
#### 替换操作

```
r: 替换当前字符
```

#### 缩进

	>>: 文本行右移
	<<: 文本行左移
#### 查看 Man Page

光标移动到函数上

- `Shift-k`：查看man文档中最先出现单词的位置

- `3Shift-k`：查看第三章的 ManPage

### 编辑模式

	进入输入模式：
	  i: 插入光标前一个字符
	  I: 插入行首
	  a: 插入光标后一个字符
	  A: 插入行未
	  o: 向下新开一行,插入行首
	  O: 向上新开一行,插入行首
	  s: 删除光标所在的字符
	  S：删除当前行
### 末行模式

只能从命令模式切换到末行模式，使用`:`

#### 行跳转

```
:123 -> 跳转到第123行
```

#### 替换

	替换光标所在行
		:s/abc/123 -> 将第一个abc替换为123
		:s/abc/123/g -> 将abc全部替换为123
	替换所有行
		:%s/abc/123 -> 将所有行中的第一个abc替换为123
		:%s/abc/123/g -> 将所有行中的abc全部替换为123
	替换指定行
		:10,30s/abc/123/g -> 将10-30行中的abc全部替换为123
#### 执行shell命令

末行模式里输入`!`，后面跟命令

### 分屏操作

末行模式

	命令：sp 将屏幕分为两部分 --> 水平
	命令：vsp 将屏幕分为两部分 --> 垂直
	命令：sp（vsp） + 文件名 水平或垂直拆分窗口显示两个不同的文件
	操作
		命令：wqall 保存并退出所有屏幕
		命令：wq 保存并退出光标所在的屏幕
		CTrl+ww 切换两个屏幕
### vim设置

#### 设置行号

##### 临时

- 显示行号：:set number 或者 :set nu 

- 隐藏行号：:set nonumber 或者 :set nonu 

##### 永久

设置配置文件，两种配置方式

- /etc/vimrc  是系统范围的初始化配置

- ～/.vimrc   个人的vim初始化配置

在配置文件输入set number 或者 set nu 就可以了



## gcc

### gcc编译的流程

![3_gcc编译的四个阶段](../images/3_gcc编译的四个阶段.png)

### 参数

- **产生目标文件 -o**
- **指定头文件目录 -I+目录** 
- 编译时定义宏 -D
- **编译优化 -On n=0∼3**
  -O0 - 没有优化
    	-O1 - 缺省值
    	O3 - 优化级别最高
- 提示更多警告信息  -Wall
- **只编译子程序 -c**
- 生成预处理文件 -E
- **包含调试信息 -g** （gdb调试的时候必须加此参数）

## 静态库

- 命名格式：lib开头，静态库名，.a结尾；eg: `libsort.a`

- 优点
  - 寻址方便，速度快
  - 库被打包到可执行程序中，直接发布可执行程序即可使用

- 缺点
  - 静态库的代码在编译过程中已经被载入可执行程序，因此体积较大
  - 如果静态函数库改变了，程序必须重新编译。

- 使用场合
  - 在核心程序上使用，保证速度，可忽视空间
  - 主流应用于80、90年代，现在很少用

### 制作

1. 得到 *.o

```
gcc *.c -c -I../include
	-c  只编译子程序
	-I  指定头文件目录
```

2. 得到静态库 libMyCalc.a

```
ar rcs libMyCalc.a *o 
（就是一个打包.o文件的过程）
		ar 工具不包含在gcc中
		r --> 将文件插入静态库中
		c --> 创建静态库，不管库是否存在
		s --> 写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。
```

3. 查看库中的符号（函数、全局变量等）

```
nm libMyCalc.a
```

### 使用静态库

```
gcc main.c lib/libMyCalc.a -I include/ -o sum

gcc + 源文件 + -L 静态库路径 + -l静态库名 + -I头文件目录 + -o 可执行文件名
gcc main.c -L lib/ -l MyCalc -I include/ -o myapp
	-L --> 指定库所在的路径
	-l --> 指定库的名字
		去掉前缀lib，去掉后缀.a，只留下中间部分
	-I --> 头文件目录位置
```

`gcc + 源文件 + -I头文件 + libxxx.a`

生成的静态库需要跟对应的头文件同时发布
	头文件中存放的是函数接口（函数声明）

![image-20210124150158525](../images/image-20210124150158525.png)

## 共享库（动态库）

- 命名格式：lib开头，动态库名，.so 结尾；eg: `libmytest.so`

- 机制：共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。
- 优点：节省内存（共享）；易于更新（动态链接）
- 缺点：延时绑定，速度略慢
- 使用场合：对速度要求不是很强烈的地方都应使用动态库
- 注意事项：动态库是否加载到内存，取决于程序是否运行。

### 共享库更新

1. 停止运行程序
2. 使用新库覆盖旧库(保证新旧库名称一致，接口一致) “接口”
3. 重新启动程序。

### 制作

1. 生成**“与位置无关”**的目标文件（*.o）

	gcc -fPIC *.c -I ../include/ -c
		参数 -fPIC 表示生成与位置无关代码
		执行完毕后生成一系列的 .o 文件
2. 将.o文件打包制作动态库

	gcc -shared -o libMyCalc.so *.o
	  参数：-shared 制作动态库
		-o：重命名生成的新文件


### 使用动态库

	gcc main.c lib/libMyCalc.so -I include/ -o app
	
	gcc main.c -L ./lib -l MyCalc -I include/ -o myapp
		-L --> 指定库所在的路径
		去掉前缀 lib
		去掉后缀 .so
		只留下中间部分
		-I --> 头文件目录位置
#### ./myapp --> 运行失败

```
查看依赖的共享库：ldd myapp 发现 libMyCalc.so 找不到
没有给动态链接器（ld-linux.so.2）指定好动态库 libMyCalc.so 的路径
解决方案
		1. 临时设置：export LD_LIBRARY_PATH=库路径，将当前目录加入环境变量，但是终端退出了就无效了。
		2. 永久设置：将上条写入家目录下.bashrc文件中
		3. 粗暴设置：直接将libmytest.so文件拷贝到/usr/lib/【/lib】目录下。(受libc库的启发)
		4. 将libmytest.so所在绝对路径追加入到/etc/ld.so.conf文件，使用sudo ldconfig -v 更新
```



```
LD_LIBRARY_PATH
作用
​		指定查找共享库（动态链接库）时除了默认路径之外的其他路径
​		该路径在默认路径之前查找
设置方法
​		用export命令来设置值
```

### "与位置无关"的意义

静态库：每次放到代码段的同一个位置

动态库：`.o`文件不会打包到可执行文件中，只是做一个符号的记录。在程序运行后再加载动态库，每次加载放的位置不同

![7_虚拟地址空间](../images/7_虚拟地址空间.png)

## GDB调试

```sh
ivan@ubuntu:/mnt/hgfs/1_3Day/MySort$ gcc *.c -o app -g
ivan@ubuntu:/mnt/hgfs/1_3Day/MySort$ ./app
```

-g: 包含调试信息

| 命令                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| l（list）               | 列出文件的代码清单<br/>	l + 行号（l 32） --> 代码从第32行开始显示<br/>	l + 文件名:函数名 --> 代码从某个函数开始显示 |
| b（break）              | 设置断点<br/>	b + 行号（b 12）--> 在第12行设置断点<br/>	b + 行号（2）+ 条件（if i=5） --> 在第2行设置断点，只有i等于5时生效 |
| info b（break）         | 查看断点信息                                                 |
| r（run）                | 运行程序                                                     |
| start                   | 单步执行，运行程序，停在第一行执行语句                       |
| disable/enable + 断点号 | 设置断点是否有效                                             |
| d（delete）+ 断点号     | 删除指定断点号对应的断点                                     |
| p(print) + 变量名       | 打印变量值                                                   |
| display + 变量名        | 追踪变量<br/>	之后每执行一步，该变量值都会被打印出来      |
| undisplay + 变量名编号  | 取消跟踪                                                     |
| n（next）               | 下一行（不会进入到函数体内部）                               |
| s（step）               | 下一步（会进入到函数体内部）                                 |
| ptyte + 变量名          | 查看变量的类型                                               |
| finish                  | 结束当前函数，返回到函数调用点                               |
| set                     | 设置变量的值 set var n=100                                   |
| q（quit）               | 退出gdb                                                      |

## Makefile

### 文件的命名规则

Makefile

makefile

### 基本规则

![1_makefile基本原则](../images/1_makefile基本原则.png)

```
目标：依赖
	命令

app:main.c add.c sub.c mul.c
	gcc main.c add.c sub.c mul.c -o app
```

目标 --> 要生成的目标文件

依赖 --> 生成目标文件需要的一些文件

命令 --> 借助依赖文件生成目标文件的手段


Makefile会把规则中的第一个目标作为终极目标

​	all:app --> all指定生成的最终目标为app

```
app:main.o add.o sub.o mul.o
	gcc main.o add.o sub.o mul.o -o app
	
main.o:main.c
	gcc -c main.c
	
add.o:add.c
	gcc -c add.c

sub.o:sub.c
	gcc -c sub.c
	
mul.o:mul.c
	gcc -c mul.c
```



### 工作原理

![2_makefile工作原理-1](../images/2_makefile工作原理-1.png)

若想生成目标，检查规则中的依赖条件是否存在，如果不存在，寻找是否有规则用来生成该依赖文件

![3_makefile工作原理-2](../images/3_makefile工作原理-2.png)

检查规则中的目标是否需要更新，必须检查它的所有依赖，依赖中有任意一个被更新，则目标必须更新

依赖文件比目标文件时间晚，则需要更新

### 执行

`make` --> 通过makefile生成目标文件

- 直接 make （使用makefile文件）
- make -f mm (指定一个名字不为makefile的文件)

`make clean` --> 清除编译生成的中间.o文件和最终目标文件

- 如果当前目录下有同名clean文件，则不执行clean对应的命令
  - 解决方案 --> 伪目标声明：.PHONY:clean
- 特殊符号
     - \- ：表示此条命令出错，make也会继续执行后续的命令。如：“-rm a.o b.o”

### 变量

```makefile
obj=main.o add.o sub.o mul.o
target=app
$(target):$(obj)
	gcc $(obj) -o $(target)
	
main.o:main.c
	gcc -c main.c
	
%.o:%.c
	gcc -c %< -o $@
```



#### 普通变量

- 变量定义及赋值：obj = a.o b.o c.o

- 变量取值：foo = $(obj)

- 由 Makefile 维护的一些变量
  		通常格式都是大写
    			CC：默认值 cc
    		有些有默认值，有些没有
    			CPPFLAGS : 预处理器需要的选项 如：-I
    			CFLAGS：编译的时候使用的参数 –Wall –g -c
    			LDFLAGS ：链接库使用的选项 –L -l
    		用户可以修改这些变量的默认值
    			CC = gcc

#### 自动变量

```
	变量
		$@ --> 规则中的目标
		$< --> 规则中的第一个依赖条件
		$^ --> 规则中的所有依赖条件
		
	模式规则
		在规则的目标定义中使用 %
		在规则的依赖条件中使用 %
		示例：
			%.o:%.c
			$(CC) –c  $< -o $@
				$< --> 表示依次取出依赖条件
				$@ --> 表示依次取出目标值
		
```

### 函数

## 系统函数IO

系统调用函数都必须考虑返回值

![4_C库IO函数工作流程](../images/4_C库IO函数工作流程.png)

### 虚拟地址空间

![6_虚拟地址空间](../images/6_虚拟地址空间.png)

### C库函数与系统函数的区别

![7_库函数与系统函数的关系](../images/7_库函数与系统函数的关系.png)

### open函数

#### 函数原型

```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

- pathname：文件的相对或绝对路径

- flags：打开方式

  > 头文件：fcntl.h

  - 必选项
    			O_RDONLY 只读打开
    			O_WRONLY 只写打开
    			O_RDWR 可读可写打开
    			互斥

  - 可选项
    			O_APPEND 表示追加。
    				如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。
    			O_CREAT 若此文件不存在则创建它。
    				使用此选项时需要提供第三个参数mode，表示该文件的访问权限。
    				文件权限由open的mode参数和当前进程的umask掩码共同决定		

    ​			O_EXCL 如果同时指定了O_CREAT，并且文件已存在，则出错返回。
    ​			O_TRUNC 如果文件已存在，则将其长度截断（Truncate）为0字节。
    ​			O_NONBLOCK 设置文件为非阻塞状态
    ​		

#### 常见错误

 	1. 打开文件不存在 
	2. 以写方式打开只读文件(打开文件没有对应权限)
	3. 以只写方式打开目录

![image-20210208144851398](../images/image-20210208144851398.png)















