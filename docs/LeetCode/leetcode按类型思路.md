# LeetCode按类型分类

## 哈希

### 1. 两数之和

输入一个数组nums和target，要求从数组中找出加和为target的两个元素，返回它们的index。

#### 题解1

1. 设置哈希表，来保存 value -> index
2. 遍历数组：若哈希表中能寻到（target-当前值），则返回两个index；若不能，则加入哈希

## 链表

### 2. 两数相加

用链表来保存两个非负整数，链头是最低位，求两个数的加和

如 (3->4->2) + (4->6->5) = (8->0->7)

#### 题解1

链表按位从低到高，即从链头到链尾逐项加和，用一个新的链表存储结果

注意：

1. 两个数位数不相同的情况需要考虑
2. 考虑进位
3. 新的链表最低位前可以设置 dummy node，来保存链表

## 字符串

### 3. 无重复字符的最长子串

给一个字符串，给出最长的子串，要求子串没有重复字符

#### 题解1：brute force

遍历所有的子串，判断每一个子串是否符合要求

> **986 / 987** test cases passed.

#### 题解2：brute force

题解1的优化：

遍历所有的字符，找出以当前字符为子串首字符的最大子串

> **986 / 987** test cases passed.

#### 题解3：活动窗口

要求：window从i到j全部符合要求；移动右边端点，需要在$O(1)$时间内确定

因为窗口内的元素都是没有重复的，如果重复，新窗口的头部，就是重复节点的下一个字符

- 使用一个hashtable来保存每个字符最后出现的位置

注意：

1. 在判断s[i]在Hashtable中之后，需要判断hashtable[s[i]]是否在当前窗口中，若不在，则不需要更改窗口起始位置

### 6. Z 字形变换

给出行数，把一个字符串转化为一个从左到右的Z字型，然后再按正常顺序输出该字符串。

#### 方法1：按行排序

在 Java 中，用 StringBuilder 来替换字符数组

1. 初始化一个字符数组，字符数组的维数为len(s)和numRows的较小值
2. 定义布尔型goingDown来表示，当前字符在字符数组中，相对上一个字符，应该向下还是向上
3. 使用curRow来表示当前字符在字符数组中的位置
4. 按字符遍历字符串，依次添加到字符数组中



### 8. 字符串转换整数 (atoi)

把一个字符串转化为32位整数，从第一个非空格开始读，读到连续的最后一个数字为止。如果越界则返回最大（小）值，如果第一个非空格的字符不是负号或数，则返回0。

#### 解法1：正则

https://leetcode-cn.com/problems/string-to-integer-atoi/solution/javazheng-ze-biao-da-shi-he-ji-ben-pi-pei-by-pqqxp/

```
^：匹配字符串开头
[\+\-]：代表一个+字符或-字符
?：前面一个字符可有可无
\d：一个数字
+：前面一个字符的一个或多个
\D：一个非数字字符
*：前面一个字符的0个或多个
```

1. 清楚左侧空格字符

   C++：`str.lstrip()`

   Java：`s1.replaceAll("^[ ]+","")`

2. 匹配正则

3. 转化为int，需要考虑32为整数范围限制

## 查找

### 4. 寻找两个正序数组的中位数

给出两个正序数组，求他们的中位数，要求时间复杂度为 $O(log(m + n))$

#### 解法1：合并数组（不满足时间复杂度要求）

原本即为有序，按顺序扫描一遍，中位数仍在中间，时间复杂度$O(m+n)$

#### 解法2：二分查找

边界情况较为复杂，中位数的取值可以在两个数组的任意位置

```python
n1 = len(nums1)
n2 = len(nums2)
k = (n1+n2+1)//2
```

若n1+n2为奇数，则k是中位数的右边一位；若n1+n2位偶数，则k是右中位数

假设合并以后的数组中，第k个元素左侧有m1+m2个元素，即m1+m2=k；其中m1个元素来自nums1，m2个元素来自nums2

目标：

二分查找m1的值，使得a[m1] > b[m2-1], b[m2] > a[m1-1]

注意：

- 因为k已知，且k=m1+m2，因此找到m1即找到m2
- 可以在开头使用调用自身，以保证总是在较短的数组上进行二分查找
- 需要考虑中位数都在同一个数组中的情况，即m1<=0或m1>=n1，或m2越界

## 动态规划

### 5. 最长回文子串

找出一个字符串s的最长回文子串，len(s) <= 1000

#### 解法1：brute force

找出所有的子串，判断其是否为回文串，然后找出最长的

时间复杂度$O(n^2)$

---

另一种暴力法是用双指针从两边夹，判断其是否是回文串。同样是找出所有的子串用以判断是否回文

#### 解法2：动态规划

- 使用一个dp\[i][j]二维数组来记录s[i,j]是否为回文串

1. 初始化hashtable

   一个字符的一定为回文串，两个字符的判断一下即可

2. 以子串的长度作为外层循环

3. `dp[i][j]= dp[i+1][j-1] && s[i]==s[j]`

4. 上述迭代方法使用时，需要 `dp[i+1][j-1]` 完成初始化

#### 解法3：中心扩散法

从中心位置尽可能向外扩散

注意：

- 中心位置可以为节点，也可以是两个节点中间
- 可定义一个辅助方法，用以寻找以某个位置为中心，向外延伸的最长子串

### 10. 正则表达式匹配

给出字符串 s 和字符规律 p，实现一个支持 . 和 * 的正则表达式匹配

. 匹配任意单个字符

\* 匹配0个或多个前面的字符

#### 解法1：正则

Java：使用字符串方法 `s.matches(p)` 直接进行匹配，需要考虑异常

#### 解法2：动态规划



## 数学

### 7. 整数反转

将一个32位有符号整数，按每一位进行反转

#### 解法1：

弹出原数字的最后一位，并加到新数字的后面

注意

- python中取摸、取整除，和java不一样

```
python 中 -1%10 = 9  ， -1//10=-1
java   中 -1%10 = 1  ， -1//10=0
```

- 考虑 INT 的范围

### 9. 回文数

判断一个数字是否是回文数

#### 解法1

将数字后半段反转，然后判断是否相等

1. 判断x<0 或 x为非0且以0结尾
2. 反转x的后半段，判断是否相等

注意：

- 需要考虑x为奇数位的情况



