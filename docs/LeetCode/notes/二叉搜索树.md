## [[编程题]二叉搜索树](https://www.nowcoder.com/questionTerminal/3d6dd9a58d5246f29f71683346bb8f1b?toCommentId=1171789)

### 题目描述

链接：https://www.nowcoder.com/questionTerminal/3d6dd9a58d5246f29f71683346bb8f1b?toCommentId=1171789
来源：牛客网

- 热度指数：5076 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 64M，其他语言128M

判断两序列是否为同一二叉搜索树序列

##### **输入描述:**

```
开始一个数n，(1<=n<=20) 表示有n个需要判断，n= 0 的时候输入结束。
接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，
根据这个序列可以构造出一颗二叉搜索树。
接下去的n行有n个序列，
每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。
```

##### **输出描述:**

```
如果序列相同则输出YES，否则输出NO
```

示例1

## 输入

```
2
567432
543267
576342
0
```

## 输出

```
YES
NO
```

### 分析

- 中序遍历和另一种遍历可以唯一确定一棵二叉树
- 对输入的数字序列构建二叉排序树，并对它们进行前序和中序的遍历，依次比较两次遍历结果是否相同，若相同则说明两棵二叉排序树相同，否则不同。

### 解法一

main函数部分

```c++
int main(){
    Solution sol;
    vector<int> pattern;
    vector<vector<int>> lists;
//    pattern={5,6,7,4,3,2};
//    lists = {{5,4,3,2,6,7},{5,7,6,3,4,2}};
    int n;
    while(cin>>n && n!=0){  //输入数据
        string s;
        cin>>s;
        for(char& c : s)
            pattern.push_back(c-'0');
        while(n--){
            vector<int> list;
            s.clear();
            cin>>s;
            for(char& c : s)
                list.push_back(c-'0');
            lists.push_back(list);
        }
    }
    //判断
    vector<bool> res = sol.isSameBST(pattern,lists);
    for(bool flag : res){
        if(flag)    cout<<"YES"<<endl;
        else    cout<<"NO"<<endl;
    }
    return 0;
}
```

solution.h部分

```c++
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};

class Solution {
public:
    vector<bool> isSameBST(vector<int>& pattern,
                           vector<vector<int>>& lists){
        vector<bool> res;
        TreeNode* root = buildTree(pattern);    //对模板建树
        vector<int> p_pre, p_in;
        preorder(root, p_pre);  //pattern的前序遍历
        inorder(root, p_in);    //pattern的中序遍历
        vector<TreeNode*> trees;
        for(auto& list : lists) //对lists建树
            trees.push_back(buildTree(list));
        for(auto& tree : trees){    //遍历所有需要判断的树
            vector<int> t_pre;
            preorder(tree, t_pre);
            if(p_pre == t_pre){ //判断
                vector<int> t_in;
                inorder(tree, t_in);
                if(p_in == t_in) res.push_back(true);
            } else  res.push_back(false);
        }
        return res;
    }
private:
    void preorder(TreeNode* p,vector<int>& vec){    //前序遍历
        if(!p)  return;
        vec.push_back(p->val);
        if(p->left) preorder(p->left,vec);
        if(p->right) preorder(p->right,vec);
    }
    void inorder(TreeNode* p,vector<int>& vec){ //中序遍历
        if(!p)  return;
        if(p->left) inorder(p->left,vec);
        vec.push_back(p->val);
        if(p->right) inorder(p->right,vec);
    }
    TreeNode* buildTree(vector<int>& vec) { //建树
        if(vec.empty()) return nullptr;
        TreeNode* root = new TreeNode(vec[0]);
        int size = vec.size();
        for(int i=1;i<size;i++){
            addNode(root, vec[i]);
        }
        return root;
    }
    void addNode(TreeNode* root, int curr){ //在BST中添加节点
        if(curr == root->val)   return;
        else if(curr < root->val){
            if(!root->left){
                TreeNode* temp = new TreeNode(curr);
                root->left = temp;
            } else addNode(root->left, curr);
        }else{
            if(!root->right){
                TreeNode* temp = new TreeNode(curr);
                root->right = temp;
            } else addNode(root->right, curr);
        }
    }
};
```

### 解法二

解法二说明

```c++

```

