## [编程题]哈夫曼树

### 题目描述

链接：https://www.nowcoder.com/questionTerminal/162753046d5f47c7aac01a5b2fcda155?f=discussion
来源：牛客网

哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。

##### **输入描述:**

```
输入有多组数据。
每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。
```

##### **输出描述:**

```
输出权值。
```

示例1

## 输入

```
5  
1 2 2 5 9
```

## 输出

```
37
```

### 分析

使用优先级队列建立小顶堆

`priority_queue<int , vector<int> , greater<int> > Q;`

弹出堆顶元素后，堆会自动调整为一个新的小顶堆。

### 解法一

- 取出最小两个元素，组成父节点后放回
- 直到队列中只有一个节点

```c++
priority_queue<int , vector<int> , greater<> > Q; //建立一个小顶堆
int main () {
    int n;
    while (cin>>n) {
        while(!Q.empty()) Q.pop(); //清空堆中元素
        for (int i = 0;i < n;i++) { //输入n个叶子结点权值
            int x;
            cin>>x;
            Q.push(x); //将权值放入堆中
        }
        int ans = 0; //保存答案
        while(Q.size() > 1) { //当堆中元素大于1个
            //取出堆中两个最小元素,他们为同一个结点的左右儿子,且该双亲结点的权值为它们的和
            int a = Q.top();Q.pop();
            int b = Q.top();Q.pop();
            ans += a + b; //该父亲结点必为非叶子结点,固累加其权值
            Q.push(a + b); //将该双亲结点的权值放回堆中
        }
        cout<<ans<<endl; //输出答案
    }
    return 0;
}
```

### 解法二

解法二说明

```c++

```

