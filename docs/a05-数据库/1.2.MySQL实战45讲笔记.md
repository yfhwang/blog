## 2.1.基础架构

> 一条SQL查询语句的执行

基本架构示意图

![download](../images/download.png)

### 连接器

```sh
mysql -h$ip -P$port -u$user -p
```

一个连接完成后进入空闲状态，可以在 show processlist 命令中看到它

### 分析器

### 优化器

### 执行器

## 2.2.日志系统

```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```



### redo log（重做日志）

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

### binlog（归档日志）

### 区别

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

update 语句执行流程：

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

![download](../images/download-7947808.png)



### 两阶段提交

如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

## 2.3.事务隔离

### 事务隔离级别

```sql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

![download](../images/download-7950724.png)

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。V1、V2、V3 都是 2。无视图概念
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 V1 是 1，V2、V3 都是 2。视图创建于每个SQL语句开始执行时。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 V1、V2 是 1，V3 是 2。视图在事务启动时创建的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 V1、V2 值是 1，V3 是2。

### 事务隔离的实现

“可重复读”

































